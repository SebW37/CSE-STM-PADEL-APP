/**
 * Exemple d'API route pour créer une réservation
 * Déplacer vers app/api/bookings/route.ts pour l'utiliser
 */
import { NextRequest, NextResponse } from 'next/server'
import { getServerUser } from '@/lib/supabase/server'
import { prisma } from '@/lib/prisma/client'
import {
  canUserCreateBooking,
  isBookingDateValid,
  isCourtAvailable
} from '@/lib/prisma/rules'
import { BookingStatus } from '@prisma/client'

export async function POST(req: NextRequest) {
  try {
    // Vérifier l'authentification
    const user = await getServerUser()
    if (!user) {
      return NextResponse.json(
        { error: 'Non authentifié' },
        { status: 401 }
      )
    }

    // Récupérer l'utilisateur en base (via Prisma)
    const dbUser = await prisma.user.findUnique({
      where: { email: user.email! }
    })

    if (!dbUser) {
      return NextResponse.json(
        { error: 'Utilisateur non trouvé en base de données' },
        { status: 404 }
      )
    }

    // Parser les données de la requête
    const body = await req.json()
    const { courtId, date, duree = 60 } = body

    if (!courtId || !date) {
      return NextResponse.json(
        { error: 'courtId et date sont requis' },
        { status: 400 }
      )
    }

    const bookingDate = new Date(date)

    // Vérifier les règles métier

    // 1. Vérifier que l'utilisateur peut créer une réservation (max 2 actives)
    const canCreate = await canUserCreateBooking(dbUser.id)
    if (!canCreate) {
      return NextResponse.json(
        {
          error: 'Limite de réservations atteinte',
          message: 'Vous avez déjà 2 réservations actives. Maximum 2 réservations par employé.'
        },
        { status: 403 }
      )
    }

    // 2. Vérifier que la date est valide (7 jours à l'avance max)
    if (!isBookingDateValid(bookingDate)) {
      return NextResponse.json(
        {
          error: 'Date invalide',
          message: 'Les réservations sont possibles jusqu\'à 7 jours à l\'avance maximum.'
        },
        { status: 400 }
      )
    }

    // 3. Vérifier que le terrain est disponible
    const isAvailable = await isCourtAvailable(courtId, bookingDate, duree)
    if (!isAvailable) {
      return NextResponse.json(
        {
          error: 'Terrain non disponible',
          message: 'Ce terrain est déjà réservé à cette date/heure.'
        },
        { status: 409 }
      )
    }

    // 4. Vérifier que le terrain existe et est actif
    const court = await prisma.court.findUnique({
      where: { id: courtId }
    })

    if (!court) {
      return NextResponse.json(
        { error: 'Terrain non trouvé' },
        { status: 404 }
      )
    }

    if (!court.actif) {
      return NextResponse.json(
        { error: 'Terrain non disponible', message: 'Ce terrain est actuellement inactif.' },
        { status: 403 }
      )
    }

    // 5. Vérifier les crédits (si applicable)
    const creditsNecessaires = 1 // Par défaut 1 crédit par réservation
    if (dbUser.soldeCredits < creditsNecessaires) {
      return NextResponse.json(
        {
          error: 'Crédits insuffisants',
          message: `Vous n'avez pas assez de crédits. Solde actuel : ${dbUser.soldeCredits}`
        },
        { status: 403 }
      )
    }

    // Créer la réservation
    const booking = await prisma.booking.create({
      data: {
        userId: dbUser.id,
        courtId: courtId,
        date: bookingDate,
        duree: duree,
        statut: BookingStatus.CONFIRME,
        creditsUtilises: creditsNecessaires
      },
      include: {
        court: true,
        user: {
          select: {
            nom: true,
            prenom: true,
            email: true
          }
        }
      }
    })

    // Déduire les crédits
    await prisma.user.update({
      where: { id: dbUser.id },
      data: {
        soldeCredits: {
          decrement: creditsNecessaires
        }
      }
    })

    return NextResponse.json(
      {
        success: true,
        booking: booking
      },
      { status: 201 }
    )
  } catch (error: any) {
    console.error('Erreur lors de la création de la réservation:', error)
    return NextResponse.json(
      { error: 'Erreur serveur', message: error.message },
      { status: 500 }
    )
  }
}

/**
 * GET : Récupérer les réservations de l'utilisateur
 */
export async function GET(req: NextRequest) {
  try {
    const user = await getServerUser()
    if (!user) {
      return NextResponse.json(
        { error: 'Non authentifié' },
        { status: 401 }
      )
    }

    const dbUser = await prisma.user.findUnique({
      where: { email: user.email! }
    })

    if (!dbUser) {
      return NextResponse.json(
        { error: 'Utilisateur non trouvé' },
        { status: 404 }
      )
    }

    const bookings = await prisma.booking.findMany({
      where: {
        userId: dbUser.id
      },
      include: {
        court: true
      },
      orderBy: {
        date: 'asc'
      }
    })

    return NextResponse.json({ bookings })
  } catch (error: any) {
    console.error('Erreur lors de la récupération des réservations:', error)
    return NextResponse.json(
      { error: 'Erreur serveur', message: error.message },
      { status: 500 }
    )
  }
}


